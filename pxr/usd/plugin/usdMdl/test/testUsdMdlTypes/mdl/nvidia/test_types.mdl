/******************************************************************************
 * Copyright 1986, 2017 NVIDIA Corporation. All rights reserved.
 ******************************************************************************/

/*
THE MDL MATERIALS ARE PROVIDED PURSUANT TO AN END USER LICENSE AGREEMENT, WHICH WAS ACCEPTED IN ORDER TO GAIN ACCESS TO THIS FILE. IN PARTICULAR, THE MDL MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL,  INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE MDL MATERIALS OR FROM OTHER DEALINGS IN THE MDL MATERIALS
*/

mdl 1.5;
//    anno::version_number(0,1,10,0),

import df::*;
import state::*;
import math::*;
import base::*;
import tex::*;
import anno::*;


export using base import texture_return;
export using base import mono_mode;
export using base import color_layer_mode;

export enum material_type
[[
    anno::description("used to annotate materials as hint for grouping in the ui"),
    anno::hidden()
]]
{
    simple_material
        [[ anno::description("Simple material") ]],
    complex_material
        [[ anno::description("Complex material") ]],
    combiner_material
        [[ anno::description("Combiner material") ]],
    modifier_material
        [[ anno::description("Material modifier") ]]
};

export enum emission_type
[[
    anno::description("Used in light sources to define the emission mode"),
    anno::hidden()
]]
{
    lumen_m2
        [[ anno::description("lumen/m2") ]],
    lumen
        [[ anno::description("lumen") ]],
    candela
        [[ anno::description("candela") ]],
    nit
        [[ anno::description("nit (candela/m2)") ]]
};

export enum cell_type
[[
    anno::description("used to define the behavior of Worley noise"),
    anno::hidden()
]]
{
    simple_cells = 0
        [[ anno::description("Simple Cells") ]],
    crystal_cells = 1
        [[ anno::description("Crystal cells") ]],
    bordered_cells = 2
        [[ anno::description("Bordered cells") ]]
};

export enum cell_base
[[
    anno::description("used to annotate materials as hint for grouping in the ui"),
    anno::hidden()
]]
{
    circular_cells = 0
        [[ anno::description("Circle base") ]],
    diamond_cells = 1
        [[ anno::description("Diamond base") ]]
};

uniform float4x4 rotation_translation_scale(
    uniform float3 rotation = float3(0.)
        [[ anno::description("Rotation applied to every UVW coordinate") ]],
    uniform float3 translation = float3(0.)
        [[ anno::description("Offset applied to every UVW coordinate") ]],
    uniform float3 scaling = float3(1.)
        [[ anno::description("Scale applied to every UVW coordinate") ]]
)
[[
    anno::description("Construct transformation matrix from Euler rotation, translation and scale"),
    anno::hidden()
]]
{
    float4x4 scale =
        float4x4(scaling.x        , 0.               , 0.               , 0.,
                 0.               , scaling.y        , 0.               , 0.,
                 0.               , 0.               , scaling.z        , 0.,
                 translation.x, translation.y, translation.z, 1.);

    float3 s = math::sin(rotation);
    float3 c = math::cos(rotation);
    float4x4 rotate =
        float4x4(  c.y*c.z ,  -c.x*s.z + s.x*s.y*c.z ,  s.x*s.z + c.x*s.y*c.z , 0.0,
                   c.y*s.z ,   c.x*c.z + s.x*s.y*s.z , -s.x*c.z + c.x*s.y*s.z , 0.0,
                  -s.y     ,   s.x*c.y               ,  c.x*c.y               , 0.0,
                   0.     ,   0                   ,  0                   , 1.);

    return   scale*rotate;
}


export annotation suitable_as_light();
export annotation type_of_material(material_type type);
export annotation ui_position(int position);
export annotation typical_object_size(float size);

const string COPYRIGHT = "THE MDL MATERIALS ARE PROVIDED PURSUANT TO AN END USER LICENSE AGREEMENT, WHICH WAS ACCEPTED IN ORDER TO GAIN ACCESS TO THIS FILE. IN PARTICULAR, THE MDL MATERIALS ARE PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL,  INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE MDL MATERIALS OR FROM OTHER DEALINGS IN THE MDL MATERIALS";


export texture_return blend_colors(
    color color_1 = color(0.0)
    [[ anno::display_name("Color 1") ]],
    color color_2 = color(1.0)
    [[ anno::display_name("Color 2") ]],
    uniform color_layer_mode mode = color_layer_blend
    [[
        anno::description("Describes how Color 1 and Color 2 are combined"),
        anno::display_name("Blend mode")
    ]],
    float weight = 1.
    [[
        anno::description("Defines strength of the effect. At weight of 0, only color 1 will be visible. At weight 1, the blend function will have full effect"),
        anno::display_name("Blend weight")
    ]]
)
[[
    anno::display_name("Blend colors"),
    anno::description("Allows combining textures in varied ways"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::blend_color_layers(
        layers: base::color_layer[](
            base::color_layer(
                layer_color: color_2,
                weight: weight,
                mode: mode
                )),
        base: color_1
    );
}

export texture_return file_texture(
    uniform texture_2d texture
    [[
        anno::display_name("Bitmap file"),
        anno::in_group("Bitmap parameters"),
        ui_position(0)
    ]],
    uniform mono_mode mono_source = mono_average
    [[
        anno::display_name("Scalar mode"),
        anno::description("Defines how the texture applies to scalar parameters"),
        anno::in_group("Bitmap parameters"),
        ui_position(1)
    ]],
    uniform float brightness = 1.
    [[
        anno::display_name("Brightness"),
        anno::in_group("Bitmap parameters"),
        ui_position(2)
    ]],
    uniform float contrast = 1.
    [[
        anno::display_name("Contrast"),
        anno::in_group("Bitmap parameters"),
        ui_position(3)
    ]],
    uniform float2 scaling = float2(1.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(8)
    ]],
    uniform float2 translation = float2(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(7)
    ]],
    uniform float rotation = 0.
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(6)
    ]],
    uniform bool clip = false
    [[
        anno::description("If set to true, texture will not repeat. Outside of the texture, color will be black and the scalar value will be 0"),
        anno::display_name("Clip"),
        anno::in_group("Placement"),
        ui_position(9)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(5)
    ]],
    uniform bool invert = false
    [[
        anno::description("Invert image"),
        anno::display_name("Invert image"),
        anno::in_group("Bitmap parameters"),
        ui_position(4)
    ]]
)
[[
    anno::display_name("Bitmap texture"),
    anno::description("Allows texturing using image files of various file formats"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return invert == false? base::file_texture(
        texture: texture,
        mono_source: mono_source,
        color_offset: color(0.5*brightness-0.5*contrast*brightness),
        color_scale: color(brightness*contrast),
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: float3(scaling.x, scaling.y, 1.0),
                rotation: float3(0.0, 0.0, rotation/180.*math::PI ),
                translation: float3(translation.x, translation.y, 0.0)
            ),
            coordinate: base::coordinate_source(texture_space: texture_space)
        ),
        wrap_u: clip?tex::wrap_clip:tex::wrap_repeat,
        wrap_v: clip?tex::wrap_clip:tex::wrap_repeat
    ): base::file_texture(
        texture: texture,
        mono_source: mono_source,
        color_offset: color(1.0-0.5*brightness+0.5*contrast*brightness),
        color_scale: color(-brightness*contrast),
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: float3(scaling.x, scaling.y, 1.0),
                rotation: float3(0.0, 0.0, rotation/180.*math::PI ),
                translation: float3(translation.x, translation.y, 0.0)
            ),
            coordinate: base::coordinate_source(texture_space: texture_space)
        ),
        wrap_u: clip?tex::wrap_clip:tex::wrap_repeat,
        wrap_v: clip?tex::wrap_clip:tex::wrap_repeat
    );
}

export texture_return perlin_noise_texture(
    color color1 = color(1.)
    [[
        anno::display_name("Color 1"),
        anno::in_group("Noise parameters"),
        ui_position(1)
    ]],
    color color2 = color(0.)
    [[
        anno::display_name("Color 2"),
        anno::in_group("Noise parameters"),
        ui_position(2)
    ]],
    uniform bool object_space = true
    [[
        anno::description("If off, UV space will be used. If on, 3d texturing in object space will apply. For applications that do not support object space, world space will be used"),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        ui_position(7)
    ]],
    uniform int noise_levels = 3.
    [[
        anno::description("Higher amounts will add detail to the noise"),
        anno::display_name("Levels"),
        anno::hard_range(1,6),
        anno::in_group("Noise parameters"),
        ui_position(3)
    ]],
    uniform bool absolute_noise = false
    [[
        anno::display_name("Billowing appearance"),
        anno::in_group("Noise parameters"),
        ui_position(4)
    ]],
    uniform float noise_threshold_high = 1.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Lowering this value will create bigger areas uniformly colored with Color 1"),
        anno::display_name("Upper threshold"),
        anno::in_group("Noise parameters"),
        ui_position(6)
    ]],
    uniform float noise_threshold_low = 0.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Increasing this value will create bigger areas uniformly colored with Color 2"),
        anno::display_name("Lower threshold"),
        anno::in_group("Noise parameters"),
        ui_position(5)
    ]],
    uniform float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(11)
    ]],
    uniform float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(10)
    ]],
    uniform float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(9)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(8)
    ]]
)
[[
    anno::display_name("Perlin noise texture"),
    anno::description("Allow texturing with a random noise pattern"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::perlin_noise_texture(
        color1: color1,
        color2: color2,
        noise_levels: noise_levels,
        absolute_noise: absolute_noise,
        noise_threshold_high: noise_threshold_high,
        noise_threshold_low: noise_threshold_low,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,

                translation: translation,
                rotation: float3(rotation.x/180.*math::PI,rotation.y/180.*math::PI,rotation.z/180.*math::PI)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export float3 perlin_noise_bump_texture(
    uniform float factor = 1.
    [[
        anno::display_name("Bump strength"),
        anno::in_group("Noise parameters"),
        ui_position(0)
    ]],
    uniform float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(9)
    ]],
    uniform int noise_levels = 1.
    [[
        anno::description("Higher amounts will add detail to the noise"),
        anno::display_name("Levels"),
        anno::hard_range(1,6),
        anno::in_group("Noise parameters"),
        ui_position(1)
    ]],
    uniform bool object_space = true
    [[
        anno::description("If off, UV space will be used. If on, 3d texturing in object space will apply. For applications that do not support object space, world space will be used"),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        ui_position(5)
    ]],
    uniform bool absolute_noise = false
    [[
        anno::display_name("Billowing appearance"),
        anno::in_group("Noise parameters"),
        ui_position(2)
    ]],
    uniform float noise_threshold_high = 1.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Lowering this value will create bigger areas uniformly colored with Color 1"),
        anno::display_name("Upper threshold"),
        anno::in_group("Noise parameters"),
        ui_position(4)
    ]],
    uniform float noise_threshold_low = 0.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Increasing this value will create bigger areas uniformly colored with Color 2"),
        anno::display_name("Lower threshold"),
        anno::in_group("Noise parameters"),
        ui_position(3)
    ]],
    uniform float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(8)
    ]],
    uniform float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(7)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(6)
    ]]
)
[[
    anno::display_name("Perlin noise texture"),
    anno::description("Allows texturing a random noise pattern"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::perlin_noise_bump_texture(
        factor: factor,
        noise_levels: noise_levels,
        absolute_noise: absolute_noise,
        noise_threshold_high: noise_threshold_high,
        noise_threshold_low: noise_threshold_low,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: scaling,
                translation: translation,
                rotation: float3(rotation.x/180.*math::PI,rotation.y/180.*math::PI,rotation.z/180.*math::PI)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export texture_return worley_noise_texture(
    color color1 = color(1.)
    [[
        anno::display_name("Color 1"),
        anno::in_group("Noise parameters"),
        ui_position(0)
    ]],
    color color2 = color(0.)
    [[
        anno::display_name("Color 2"),
        anno::in_group("Noise parameters"),
        ui_position(1)
    ]],
    uniform bool object_space = true
    [[
        anno::description("If off, UV space will be used. If on, 3d texturing in object space will apply. For applications that do not support object space, world space will be used"),
        anno::display_name("Use object space") ,
        anno::in_group("Placement"),
        ui_position(6)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(7)
    ]],
    uniform cell_type mode = simple_cells
    [[
        anno::display_name("Cell type") ,
        anno::description("Cell pattern type"),
        anno::in_group("Noise parameters"),
        ui_position(2)
    ]],
    uniform cell_base metric = circular_cells
    [[
        anno::display_name("Cell shape") ,
        anno::description("The shape of the cell form"),
        anno::in_group("Noise parameters"),
        ui_position(3)
    ]],
    uniform float noise_threshold_high = 1.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Lowering this value will create bigger areas uniformly colored with Color 1"),
        anno::display_name("Upper threshold"),
        anno::in_group("Noise parameters"),
        ui_position(5)
    ]],
    uniform float noise_threshold_low = 0.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Increasing this value will create bigger areas uniformly colored with Color 2"),
        anno::display_name("Lower threshold"),
        anno::in_group("Noise parameters"),
        ui_position(4)
    ]],
    uniform float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(10)
    ]],
    uniform float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(9)
    ]],
    uniform float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(8)
    ]])
[[
    anno::display_name("Cellular noise texture"),
    anno::description("Allow texturing with a cell forming pattern"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::worley_noise_texture(
        color1: color1,
        color2: color2,
        mode: mode==crystal_cells?2:mode==bordered_cells?3:0,
        metric: metric,
        noise_threshold_high: noise_threshold_high,
        noise_threshold_low: noise_threshold_low,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: float3(rotation.x/180.*math::PI,rotation.y/180.*math::PI,rotation.z/180.*math::PI)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export float3 worley_noise_bump_texture(
    uniform float factor = 1.
    [[
        anno::display_name("Bump strength"),
        anno::in_group("Noise parameters"),
        ui_position(0)
    ]],
    uniform cell_base metric = circular_cells
    [[
        anno::display_name("Cell shape") ,
        anno::description("The shape of the cell form"),
        anno::in_group("Noise parameters"),
        ui_position(1)
    ]],
    uniform bool object_space = true
    [[
        anno::description("If off, UV space will be used. If on, 3d texturing in object space will apply. For applications that do not support object space, world space will be used"),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        ui_position(4)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(5)
    ]],
    uniform float noise_threshold_high = 1.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Lowering this value will create bigger areas uniformly colored with Color 1"),
        anno::display_name("Upper threshold"),
        anno::in_group("Noise parameters"),
        ui_position(3)
    ]],
    uniform float noise_threshold_low = 0.
    [[
        anno::hard_range(0.0,1.),
        anno::description("Increasing this value will create bigger areas uniformly colored with Color 2"),
        anno::display_name("Lower threshold"),
        anno::in_group("Noise parameters"),
        ui_position(2)
    ]],
    uniform float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(8)
    ]],
    uniform float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(7)
    ]],
    uniform float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(6)
    ]])
[[
    anno::display_name("Cellular noise texture"),
    anno::description("Allow texturing with a cell forming pattern"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::worley_noise_bump_texture(
        factor: factor,
        metric: metric,
        noise_threshold_high: noise_threshold_high,
        noise_threshold_low: noise_threshold_low,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: float3(rotation.x/180.*math::PI,rotation.y/180.*math::PI,rotation.z/180.*math::PI)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export texture_return flow_noise_texture(
    color color1 = color(1.)
    [[
        anno::display_name("Color 1"),
        anno::in_group("Noise parameters"),
        ui_position(0)
    ]],
    color color2 = color(0.)
    [[
        anno::display_name("Color 2"),
        anno::in_group("Noise parameters"),
        ui_position(1)
    ]],
    uniform bool object_space = false
    [[
        anno::description("If off, UV space will be used. If on, 3d texturing in object space will apply. For applications that do not support object space, world space will be used"),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        ui_position(10)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(11)
    ]],
    uniform int noise_levels = 3.
    [[
        anno::description("Higher amounts will add detail to the noise"),
        anno::display_name("Levels"),
        anno::hard_range(1,6),
        anno::in_group("Noise parameters"),
        ui_position(3)

    ]],
    uniform bool absolute_noise = false
    [[
        anno::display_name("Billowing appearance"),
        anno::in_group("Noise parameters"),
        ui_position(4)

    ]],
    uniform float phase = 0.0
    [[
        anno::display_name("Phase offset"),
        anno::description("Controls the 3rd dimension of the function"),
        anno::in_group("Noise parameters")
        ,
        ui_position(5)
    ]],
    uniform float level_gain = 0.5
    [[
        anno::display_name("Level intensity gain"),
        anno::description("If multiple levels are used, \"level_gain\" specifies a weighting factor for subsequent levels"),
        anno::in_group("Noise parameters"),
        ui_position(6)
    ]],
    uniform float level_scale = 2.0
    [[
        anno::display_name("Level scaling"),
        anno::description("If multiple levels are used, \"level_scale\" specifies a global scaling factor for subsequent levels"),
        anno::in_group("Noise parameters"),
        ui_position(7)
    ]],
    uniform float level_progressive_u_scale = 1.
    [[
        anno::display_name("Progressive u scale"),
        anno::description("If multiple levels are used, \"level_progressive_u_scale\" specifies an additional scaling factor in the \"u\" direction"),
        anno::in_group("Noise parameters"),
        ui_position(8)
    ]],
    uniform float level_progressive_v_motion = 0.
    [[
        anno::display_name("Progressive v offset"),
        anno::description("If multiple levels are used, \"level_progressive_v_motion\" specifies an offset for subsequent levels in the \"v\" direction"),
        anno::in_group("Noise parameters"),
        ui_position(9)
    ]],
    uniform float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(15)
    ]],
    uniform float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(14)
    ]],
    uniform float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(13)
    ]])
[[
    anno::display_name("Flow noise texture"),
    anno::description("Allow texturing with a 2D noise pattern suitable for waves"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::flow_noise_texture(
        color1: color1,
        color2: color2,
        levels: noise_levels,
        phase: phase,
        level_gain: level_gain,
        level_scale: level_scale,
        level_progressive_u_scale: level_progressive_u_scale,
        level_progressive_v_motion: level_progressive_v_motion,
        absolute_noise: absolute_noise,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: float3(rotation.x/180.*math::PI,rotation.y/180.*math::PI,rotation.z/180.*math::PI)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export float3 flow_noise_bump_texture(
    uniform float factor = 1.
    [[
        anno::display_name("Bump strength"),
        anno::in_group("Noise parameters"),
        ui_position(0)
    ]],
    uniform float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(12)
    ]],
    uniform int noise_levels = 1.
    [[
        anno::description("Higher amounts will add detail to the noise"),
        anno::display_name("Levels"),
        anno::hard_range(1,6),
        anno::in_group("Noise parameters"),
        ui_position(1)
    ]],
    uniform bool object_space = false
    [[
        anno::description("If off, UV space will be used. If on, 3d texturing in object space will apply. For applications that do not support object space, world space will be used"),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        ui_position(8)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(9)
    ]],
    uniform bool absolute_noise = false
    [[
        anno::display_name("Billowing appearance"),
        anno::in_group("Noise parameters"),
        ui_position(2)
    ]],
    uniform float phase = 0.0
    [[
        anno::display_name("Phase offset"),
        anno::description("Controls the 3rd dimension of the function"),
        anno::in_group("Noise parameters"),
        ui_position(3)
    ]],
    uniform float level_gain = 0.5
    [[
        anno::display_name("Level intensity gain"),
        anno::description("If multiple levels are used, \"level_gain\" specifies a weighting factor for subsequent levels"),
        anno::in_group("Noise parameters"),
        ui_position(4)
    ]],
    uniform float level_scale = 2.0
    [[
        anno::display_name("Level scaling"),
        anno::description("If multiple levels are used, \"level_scale\" specifies a global scaling factor for subsequent levels"),
        anno::in_group("Noise parameters"),
        ui_position(5)
    ]],
    uniform float level_progressive_u_scale = 1.
    [[
        anno::display_name("Progressive u scale"),
        anno::description("If multiple levels are used, \"level_progressive_u_scale\" specifies an additional scaling factor in the \"u\" direction"),
        anno::in_group("Noise parameters"),
        ui_position(6)
    ]],
    uniform float level_progressive_v_motion = 0.
    [[
        anno::display_name("Progressive v offset"),
        anno::description("If multiple levels are used, \"level_progressive_v_motion\" specifies an offset for subsequent levels in the \"v\" direction"),
        anno::in_group("Noise parameters"),
        ui_position(7)
    ]],
    uniform float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(11)
    ]],
    uniform float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(10)
    ]])
[[
    anno::display_name("Flow noise texture"),
    anno::description("Allow texturing with a 2D noise pattern suitable for waves"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::flow_noise_bump_texture(
        factor: factor,
        levels: noise_levels,
        phase: phase,
        level_gain: level_gain,
        level_scale: level_scale,
        level_progressive_u_scale: level_progressive_u_scale,
        level_progressive_v_motion: level_progressive_v_motion,
        absolute_noise: absolute_noise,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: float3(rotation.x/180.*math::PI,rotation.y/180.*math::PI,rotation.z/180.*math::PI)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export texture_return checker_texture(
    color color1 = color(1.)
    [[
        anno::display_name("Color 1"),
        anno::in_group("Checker parameters"),
        ui_position(0)
    ]],
    color color2 = color(0.)
    [[
        anno::display_name("Color 2"),
        anno::in_group("Checker parameters"),
        ui_position(1)
    ]],
    uniform float3 scaling = float3(10.)
     [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(7)
    ]],
    uniform float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(6)
    ]],
    uniform bool object_space = false
    [[
        anno::description("If off, UV space will be used. If on, 3d texturing in object space will apply. For applications that do not support object space, world space will be used"),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        ui_position(3)
    ]],
    uniform float blur = 0
    [[
        anno::hard_range(0.0,1.0),
        anno::display_name("Blur"),
        anno::in_group("Checker parameters"),
        ui_position(2)
    ]],
    uniform float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(5)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(4)
    ]]
)
[[
    anno::display_name("3d checker texture"),
    anno::description("Allows texturing a checkerboard pattern"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::checker_texture(
        color1: color1,
        color2: color2,
        blur: blur/4.,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: float3(rotation.x/180.*math::PI,rotation.y/180.*math::PI,rotation.z/180.*math::PI)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export float3 checker_bump_texture(
    uniform float factor = 1.
    [[
        anno::display_name("Bump strength"),
        anno::in_group("Checker parameters"),
        ui_position(0)
    ]],
    uniform float blur = 0
    [[
        anno::hard_range(0.0,1.0),
        anno::display_name("Blur"),
        anno::in_group("Checker parameters"),
        ui_position(1)
    ]],
    uniform bool object_space = false
    [[
        anno::description("If off, UV space will be used. If on, 3d texturing in object space will apply. For applications that do not support object space, world space will be used"),
        anno::display_name("Use object space"),
        anno::in_group("Placement"),
        ui_position(2)
    ]],
    uniform float3 scaling = float3(10.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(6)
    ]],
    uniform float3 translation = float3(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(5)
    ]],
    uniform float3 rotation = float3(0.)
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(4)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Only applies if \"Use object space\" is off. Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(3)
    ]]
)
[[
    anno::display_name("3d checker texture"),
    anno::description("Allows texturing a checkerboard pattern"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::checker_bump_texture(
        factor: factor,
        blur: blur/4.,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: object_space?scaling*state::meters_per_scene_unit() :scaling,
                translation: translation,
                rotation: float3(rotation.x/180.*math::PI,rotation.y/180.*math::PI,rotation.z/180.*math::PI)
            ),
            coordinate: object_space?
                base::coordinate_source(coordinate_system: base::texture_coordinate_object):
                base::coordinate_source(texture_space: texture_space)
        )
    );
}

export float3 file_bump_texture(
    uniform texture_2d texture
    [[
        anno::display_name("Bitmap file"),
        anno::in_group("Bitmap parameters"),
        ui_position(1)
    ]],
    uniform mono_mode bump_source = mono_average
    [[
        anno::display_name("Bump mode"),
        anno::description("Defines how the texture is evaluated to create the bumps"),
        anno::in_group("Bitmap parameters"),
        ui_position(2)
    ]],
    uniform float2 scaling = float2(1.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(8)
    ]],
    uniform float2 translation = float2(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(7)
    ]],
    uniform float rotation = 0.
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(6)
    ]],
    uniform bool clip = false
    [[
        anno::description("If set to true, texture will not repeat. Outside of the texture the surface will be flat"),
        anno::display_name("Clip"),
        anno::in_group("Placement"),
        ui_position(5)

    ]],
    uniform float factor = 1
    [[
        anno::display_name("Bump strength"),
        anno::in_group("Bitmap parameters"),
        ui_position(3)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(4)
    ]]
)
[[
    anno::display_name("Bitmap texture"),
    anno::description("Allows texturing using image files of various file formats"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::file_bump_texture(
        texture: texture,
        bump_source: bump_source,
        factor: factor,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: float3(scaling.x, scaling.y, 1.0),
                rotation: float3(0.0, 0.0, rotation/180.*math::PI ),
                translation: float3(translation.x, translation.y, 0.0)
            ),
            coordinate: base::coordinate_source(texture_space: texture_space)
        ),
        wrap_u: clip?tex::wrap_clamp:tex::wrap_repeat,
        wrap_v: clip?tex::wrap_clamp:tex::wrap_repeat,
        clip: clip
    );
}

export float3 normalmap_texture(
    uniform texture_2d texture
    [[
        anno::display_name("Normalmap file"),
        anno::in_group("Normalmap parameters"),
        ui_position(1)
    ]],
    uniform float2 scaling = float2(1.)
    [[
        anno::description("Controls the scale of the texture on the object"),
        anno::display_name("Tiling"),
        anno::in_group("Placement"),
        ui_position(7)
    ]],
    uniform float2 translation = float2(0.)
    [[
        anno::description("Controls position of the texture on the object"),
        anno::display_name("Offset"),
        anno::in_group("Placement"),
        ui_position(6)
    ]],
    uniform float rotation = 0.
    [[
        anno::description("Rotation angle of the texture in degrees"),
        anno::display_name("Rotation"),
        anno::in_group("Placement"),
        ui_position(5)
    ]],
    uniform bool clip = false
    [[
        anno::description("If set to true, texture will not repeat. Outside of the texture the surface will be flat"),
        anno::display_name("Clip"),
        anno::in_group("Placement"),
        ui_position(4)

    ]],
    uniform float factor = 1
    [[
        anno::display_name("Strength"),
        anno::in_group("Normalmap parameters"),
        ui_position(2)
    ]],
    uniform int texture_space = 0
    [[
        anno::description("Selects a specific UV space"),
        anno::display_name("UV space index"),
        anno::hard_range(0,3),
        anno::in_group("Placement"),
        ui_position(3)
    ]]
)
[[
    anno::display_name("Normalmap texture"),
    anno::description("Allows the use of tangent space normal maps"),
    anno::author("NVIDIA Corporation"),
    anno::version_number(0,1,9,0),
    anno::copyright_notice(COPYRIGHT)
]]
{
    return base::tangent_space_normal_texture(
        texture: texture,
        factor: factor,
        uvw: base::transform_coordinate(
            transform: rotation_translation_scale(
                scaling: float3(scaling.x, scaling.y, 1.0),
                rotation: float3(0.0, 0.0, rotation/180.*math::PI ),
                translation: float3(translation.x, translation.y, 0.0)
            ),
            coordinate: base::coordinate_source(texture_space: texture_space)
        ),
        wrap_u: clip?tex::wrap_clamp:tex::wrap_repeat,
        wrap_v: clip?tex::wrap_clamp:tex::wrap_repeat,
        clip: clip
    );
}

export float dummy_float_function() {return 3.14;}

// A simple struct.
export struct example_struct {
    int param_int;
    float param_float = 0.0;
};

// A complex struct which references another struct.
export struct complex_struct {
    int param_int;
    example_struct param_struct;
};

//material section
//export
material testMaterial(
	bool test_bool,
	int test_int = 2
)
 =  material(
    thin_walled: true,
    surface: material_surface(
        scattering: df::weighted_layer(
            weight: 1.,
            layer: df::diffuse_reflection_bsdf(
                    roughness: 1,
                    tint: color(.8)
            )
        )
    )
);

export
material materialWithEnum(
  uniform color_layer_mode mode = color_layer_blend

) =  material();

// A simple struct.
//export
struct simple_struct {
    int paramInt;
    float paramFloat = 0.0;
};

//export
material materialWithStructure(
  simple_struct structInput = simple_struct(1, 2.0),
  uniform texture_2d test_texture = texture_2d("./dummy.jpg", ::tex::gamma_default)

) =  material();

//export
material simpleMaterial(
    int param_int = 1,
    float param_float = 2.0
) =  material();

//export
material materialWithMaterialInput(
  material materialInput = simpleMaterial()
) =  material();

export
material diffuse(
	
    // Test simple types
	bool test_bool = true,
	int test_int = true,
	material_type test_enum = complex_material,
	float roughness = 0.0
    [[
        anno::display_name("Diffuse roughness"),
        anno::hard_range(0.0,1.),
        anno::description("Higher roughness values lead a powdery appearance")
    ]],
	double test_double = 3.14,
	string test_string = "Test string",
    color diffuse_color = color(.8)
    [[
        anno::display_name("Color"),
        anno::description("The color of the material")
    ]],
	uniform texture_2d test_texture = texture_2d("./dummy.jpg", ::tex::gamma_default),

	// Test vectors
	// MDL provides two, three, and four component vector types with either float, double, int, or bool
	// component types. Vectors are named by taking the component type name and appending the dimension
	// of the vector, which can be 2, 3, or 4.
	bool2 test_bool2 = bool2(true,false),
	bool3 test_bool3 = bool3(true),
	bool4 test_bool4 = bool4(true),
	int2 test_int2 = int2(1,2),
	int3 test_int3 = int3(3),
	int4 test_int4 = int4(4),
	float2 test_float2 = float2(1.0,2.0),
	float3 test_float3 = float3(3.0),
	float4 test_float4 = float4(4.0),
	double2 test_double2 = double2(1.0,2.0),
	double3 test_double3 = double3(3.0),
	double4 test_double4 = double4(4.0),	

	// Test matrices
	// built-in matrix types are: float2x2, float2x3, float3x2, float3x3, float3x4, float4x2,
	// float2x4, float4x3, float4x4, double2x2, double2x3, double3x2, double3x3, double3x4, double4x2,
	// double2x4, double4x3, and double4x4.
	float2x2 test_float2x2 = float2x2(1,2,3,4),
	float3x3 test_float3x3 = float3x3(1),
	float4x4 test_float4x4 = float4x4(2),
	float3x2 test_float3x2 = float3x2(1), // Error, not supported
	double2x2 test_double2x2 = double2x2(2),
	double3x3 test_double3x3 = double3x3(2),
	double4x4 test_double4x4 = double4x4(2),
	
	// Test arrays of simple types
	bool[4] bool_array = bool[](true,false,true,false),
	int[4] int_array = int[](1,2,3,4),
	float[4] float_array = float[](1.0,2.0,3.0,4.0),
	double[4] double_array = double[](1.0,2.0,3.0,4.0),
	string[4] string_array = string[]("1.0","2.0","3.0","4.0"),
	color[4] color_array = color[](color(.8),color(.8),color(.8),color(.8)),

	// Test arrays of vectors
	bool2[2] bool2_array_of_vectors = bool2[](bool2(true,false),bool2(false,true)),
	bool3[2] bool3_array_of_vectors = bool3[](bool3(true,false, false),bool3(false,true,true)),
	bool4[2] bool4_array_of_vectors = bool4[](bool4(true,false, false, false),bool4(false,true,true,true)),
	int2[2] int2_array_of_vectors = int2[](int2(1,2),int2(3,4)),
	int3[2] int3_array_of_vectors = int3[](int3(1,2,3),int3(4,5,6)),
	int4[2] int4_array_of_vectors = int4[](int4(1,2,3,4),int4(5,6,7,8)),
	float2[3] float2_array_of_vectors = float2[](float2(1.0,2.0),float2(3.0,4.0),float2(5.0,6.0)),
	float3[3] float3_array_of_vectors = float3[](float3(1.0,2.0,2.5),float3(3.0,4.0,4.5),float3(5.0,6.0,6.5)),
	float4[3] float4_array_of_vectors = float4[](float4(1.0,2.0,2.5,2.6),float4(3.0,4.0,4.5,4.6),float4(5.0,6.0,6.5,6.6)),
	double2[2] double2_array_of_vectors = double2[](double2(5,6),double2(7,8)),
	double3[2] double3_array_of_vectors = double3[](double3(5,6,7),double3(7,8,9)),
	double4[2] double4_array_of_vectors = double4[](double4(5,6,7,8),double4(7,8,9,10)),
	
	// Test function call
	texture_return file_tex = file_texture(texture: texture_2d("./dummy.jpg")),
	
	// float3 perlin_parm = perlin_noise_bump_texture(dummy_float_function()), // CRASH - WHY?
	
	// Test structure
	example_struct test_struct = example_struct(1,1.0),
//	complex_struct test_struct2 = complex_struct(),
//	example_struct test_struct = example_struct(),
	
    float3 normal = state::normal()
    [[
        anno::display_name("Bumps"),
        anno::description("Attach bump or normal maps here")
    ]]
)
[[
    anno::display_name("Simple diffuse"),
    anno::description("A basic diffuse material"),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
    anno::version_number(0,1,9,0),
    type_of_material(simple_material),
    typical_object_size(1.0),
   anno::key_words(string[]("generic"))
]]
 =  material(
    thin_walled: true,
    surface: material_surface(
        scattering: df::weighted_layer(
            weight: 1.,
            normal: normal,
            layer: df::diffuse_reflection_bsdf(
                    roughness: roughness,
                    tint: diffuse_color
            )
        )
    )
);

//export
material materialWithTextureInput(
  base::texture_return textureInput = base::file_texture( texture : texture_2d("dummy.jpg") )
) =  material(surface: material_surface
(
        scattering : df::diffuse_reflection_bsdf
		(
			tint: textureInput.tint
		)
)
);

//export
material materialWithAnnotations(
	int int_parm = 0.0
    [[
		anno::hard_range(-3,4),
		anno::soft_range(-3,4)
    ]],
	uniform int2 int2_parm = int2(0,1)
	[[
        anno::hard_range(int2(0),int2(1)),
        anno::soft_range(int2(0),int2(1))
    ]],
	uniform int3 int3_parm = int3(0,1,2)
	[[
        anno::hard_range(int3(0),int3(3)),
        anno::soft_range(int3(0),int3(3))
    ]],
	uniform int4 int4_parm = int4(0,1,2,3)
	[[
        anno::hard_range(int4(0),int4(3)),
        anno::soft_range(int4(0),int4(3))
    ]],
	float float_parm = 0.0
    [[
        anno::display_name("float_parm display name"),
        anno::in_group("float_parm group", "float_parm Subgroup", "float_parm Subsubgroup"),
        anno::hard_range(-10,20),
        anno::soft_range(-3,10),
        anno::description("Description for the float_parm values"),
		anno::key_words(string[]("generic","dielectric","plastic","wood","stone")),
		anno::hidden(),
		anno::unused(),
		anno::author("Author"),
		anno::contributor("Contributor"),
		anno::copyright_notice("Copyright notice"),
		anno::created(2019, 12, 6, "created string notes"),
		anno::modified(2019, 12, 6, "modified string notes"),		
		anno::deprecated("Deprecated string"),
		anno::origin("string name"),
		anno::ui_order(1),
		anno::usage("string hint"),
		anno::version(6,0,1,"Prerelease notes"),
		anno::enable_if("1==1"),
		anno::dependency("string modulename",1,2,3,"string prerelease")
    ]],
	uniform float2 float2_parm = float2(78,79)
	[[
        anno::in_group("float2_parm group", "float2_parm Subgroup"),
        anno::hard_range(float2(-10,-11),float2(100,101)),
        anno::soft_range(float2(-10,-11),float2(100,101))
    ]],
	uniform float3 float3_parm = float3(0,1,2)
	[[
        anno::in_group("float3_parm group"),
        anno::hard_range(float3(0),float3(3)),
        anno::soft_range(float3(0),float3(3))
    ]],
	uniform float4 float4_parm = float4(0,1,2,3)
	[[
        anno::hard_range(float4(0),float4(3)),
        anno::soft_range(float4(0),float4(3))
    ]],
	uniform double double_parm = double(3.14)
	[[
        anno::hard_range(0,10),
        anno::soft_range(0,10)
    ]],
	uniform double2 double2_parm = double2(78,79)
	[[
        anno::hard_range(double2(-10,-11),double2(100,101)),
        anno::soft_range(double2(-10,-11),double2(100,101))
    ]],
	uniform double3 double3_parm = double3(0,1,2)
	[[
        anno::hard_range(double3(0),double3(3)),
        anno::soft_range(double3(0),double3(3))
    ]],
	uniform double4 double4_parm = double4(0,1,2,3)
	[[
        anno::hard_range(double4(0),double4(3)),
        anno::soft_range(double4(0),double4(3))
    ]],
	color color_parm = color(0.4)
    [[
		anno::soft_range(color(0.01), color(.9)),
		anno::hard_range(color(0.01), color(.9)),
		anno::deprecated(),
		anno::unused("Unused string")
	]]
)
[[
	anno::thumbnail("dummy.jpg"),
    anno::display_name("Material display name"),
    anno::description("A basic material"),
    anno::author("NVIDIA Corporation"),
    anno::copyright_notice(COPYRIGHT),
	anno::version(6,0,1,"Prerelease notes"),
    type_of_material(simple_material),
    typical_object_size(1.0),
	anno::key_words(string[]("generic"))
]] 
=  material(surface: material_surface
(
        scattering : df::diffuse_reflection_bsdf
		(
		)
)
);

// User defined annotations
export annotation test_annotation_standard(bool p1 = bool(true), int p2 = int(1), float p3 = float(1), double p4 = double(1));
export annotation test_annotation_standard2(bool2 p1 = bool2(true), int2 p2 = int2(1), float2 p3 = float2(1), double2 p4 = double2(1));
export annotation test_annotation_standard3(bool3 p1 = bool3(true), int3 p2 = int3(1), float3 p3 = float3(1), double3 p4 = double3(1));
export annotation test_annotation_standard4(bool4 p1 = bool4(true), int4 p2 = int4(1), float4 p3 = float4(1), double4 p4 = double4(1));
export annotation test_annotation_color(color col);
export annotation test_annotation_string(string s = string("test string"));
// float2x2jfloat2x3jfloat2x4jfloat3x2jfloat3x3jfloat3x4jfloat4x2jfloat4x3jfloat4x4
export annotation test_annotation_matrix(float2x2 p1 = float2x2(1), float2x3 p2 = float2x3(2), float2x4 p3 = float2x4(3), float3x2 p5 = float3x2(5),
  float3x3 p6 = float3x3(1,2,3,4,5,6,7,8,9), float3x4 p7 = float3x4(7), float4x2 p8 = float4x2(8), float4x3 p9 = float4x3(9), float4x4 p10 = float4x4(10));

// Forbidden
// export annotation test_annotation_other(bsdf b = bsdf());
// export annotation test_annotation_other(edf b = edf());
// export annotation test_annotation_other(light_profile b = light_profile());
// export annotation test_annotation_other(bsdf_measurement b = bsdf_measurement());
// export annotation test_annotation_other(texture_2d b = texture_2d());

//export
material simpleMaterialWithUserDefinedAnnotations(
    uniform double3 double3_parm = double3(0,1,2)
    [[
		test_annotation_matrix(),
		test_annotation_string(),
		test_annotation_color(color(.1)),
		test_annotation_standard(),
		test_annotation_standard2(),
		test_annotation_standard3(),
		test_annotation_standard4(),
        anno::hard_range(double3(0),double3(3)),
        anno::soft_range(double3(0),double3(3))
    ]]
)
[[
    type_of_material(simple_material),
    typical_object_size(1.0)
]] 
=  material(surface: material_surface
(
        scattering : df::diffuse_reflection_bsdf
		(
		)
)
);

//export
material materialWithVectorParm(
	int int_parm = 0.0,
	uniform int2 int2_parm = int2(0,1)
)
=  material(surface: material_surface
(
        scattering : df::diffuse_reflection_bsdf
		(
		)
)
);

export annotation test_annotation_empty_expression();

//export
material materialWithAnnotationWithoutExpressions(
	int int_parm = 0.0
    [[
        anno::unused(),
        anno::deprecated(),
        anno::hidden(),
        test_annotation_empty_expression()
    ]]
)
    [[
        anno::unused(),
        anno::noinline(), // for material and functions only
        anno::deprecated(),
        anno::hidden(),
        test_annotation_empty_expression()
    ]]
=  material(surface: material_surface
(
        scattering : df::diffuse_reflection_bsdf
		(
		)
)
);

//export
material material_MDL_420(
	// float3x2 is an array of size 3, each element is a float2
      float3x2 test_float3x2 = float3x2( 1, 2, 3, 4, 5, 6 )
	  [[anno::display_name("test_float3x2")]]
	, float3x4 test_float3x4 = float3x4( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 )
	, float2x3 test_float2x3 = float2x3(1)
	, float2x4 test_float2x4 = float2x4(1)
	, float4x2 test_float4x2 = float4x2(1)
	, float4x3 test_float4x3 = float4x3(1)
	, float3x3 test_float3x3 = float3x3( 1, 2, 3, 4, 5, 6, 7, 8, 9 )
	, float2[3] float2_array_of_vectors = float2[](float2(1.0,2.0),float2(3.0,4.0),float2(5.0,6.0))
	, double2x3 test_double2x3 = double2x3( 1, 2, 3, 4, 5, 6 )
	, double2x4 test_double2x4 = double2x4(1)
	, double3x2 test_double3x2 = double3x2(1)
	, double3x4 test_double3x4 = double3x4(1)
	, double4x2 test_double4x2 = double4x2(1)
	, double4x3 test_double4x3 = double4x3(1)
)
=  material(surface: material_surface
(
        scattering : df::diffuse_reflection_bsdf
		(
		)
)
);

// Arrays of matrices
//export
material material_MDL_423(

	// Array of matrix: square
	  double2x2[3] test_double2x2 = double2x2[](1,1,1)
	, double3x3[2] test_double3x3 = double3x3[](1,1)
	, double4x4[1] test_double4x4 = double4x4[](1)
	, float2x2[3] test_float2x2 = float2x2[](1,1,1)
	, float3x3[2] test_float3x3 = float3x3[](1,1)
	, float4x4[1] test_float4x4 = float4x4[](1)
	
	// Array of matrix: non-square
	, double2x3[1] test_double2x3 = double2x3[](1)
	, double2x4[1] test_double2x4 = double2x4[](1)
	, double3x2[1] test_double3x2 = double3x2[](1)
	, double3x4[1] test_double3x4 = double3x4[](1)
	, double4x2[1] test_double4x2 = double4x2[](1)
	, double4x3[1] test_double4x3 = double4x3[](1)
	, float2x3[1] test_float2x3 = float2x3[](1)
	, float2x4[1] test_float2x4 = float2x4[](1)
	, float3x2[1] test_float3x2 = float3x2[](1)
	, float3x4[1] test_float3x4 = float3x4[](1)
	, float4x2[1] test_float4x2 = float4x2[](1)
	, float4x3[1] test_float4x3 = float4x3[](float4x3(1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.5,0.0))
	
	// size deferred array
	, float[<n>] test_size_deferred = float[2](1, 2)
	
	// Array of enum
	, material_type[4] test_enum_array = material_type[4](simple_material,complex_material,combiner_material,modifier_material)
	, material_type test_enum = combiner_material

	// Array of struct
	, example_struct test_struct = example_struct(1,1.0)
	
	// Arrays not supported in MDL
	// , light_profile[1] test_light_profile = light_profile[1](light_profile())
	// , bsdf_measurement[1] test_bsdf_measurement = bsdf_measurement[1](bsdf_measurement())
	// , bsdf[1] test_bsdf = bsdf[1](bsdf())
	// , edf[1] test_edf = edf[1](edf())
	// , vdf[1] test_vdf = vdf[1](vdf())
	// , uniform texture_2d[2] test_texture_array = texture_2d[](texture_2d("./dummy.jpg", ::tex::gamma_default),texture_2d("./dummy.jpg", ::tex::gamma_default))
)
=  material(surface: material_surface
(
        scattering : df::diffuse_reflection_bsdf
		(
		)
)
);

// MDL-421 Add MDL light_profile support for USD SDK
//export
material material_MDL_421(
	uniform light_profile test_light_profile = light_profile("./test.ies")
	, uniform light_profile test_light_profile_2 = light_profile(light_profile("./test.ies"))
	, uniform light_profile test_light_profile_3 = light_profile(test_light_profile_2)
)
=  material(surface: material_surface
(
        scattering : df::diffuse_reflection_bsdf
		(
		)
)
);

// MDL-422 Add MDL BSDF measurement support for USD SDK
export
material material_MDL_422(
	uniform bsdf_measurement test_bsdf_measurement = bsdf_measurement("./test.mbsdf")
)
=  material(surface: material_surface
(
        scattering : df::diffuse_reflection_bsdf
		(
		)
)
);
